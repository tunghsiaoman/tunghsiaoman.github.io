{"meta":{"title":"Alex's blog","subtitle":"","description":"","author":"Alex Tung","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2020-05-02T03:33:26.000Z","updated":"2020-05-02T03:33:26.366Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2020-05-02T03:34:28.000Z","updated":"2020-05-02T03:34:28.601Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-02T03:34:13.000Z","updated":"2020-05-02T03:34:13.721Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"links","date":"2020-05-02T13:42:35.000Z","updated":"2020-05-02T13:42:35.679Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"repository","date":"2020-05-02T13:42:19.000Z","updated":"2020-05-02T13:42:19.359Z","comments":true,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式 | 简单工厂模式","slug":"设计模式-简单工厂模式","date":"2020-05-02T14:19:00.000Z","updated":"2020-05-02T15:09:42.200Z","comments":true,"path":"2020/05/02/设计模式-简单工厂模式/","link":"","permalink":"http://yoursite.com/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义简单工厂模式（Simple Factory Pattern）：又称为静态工厂方法（Static Factory Method）模式，它属于类创建型模式，在简单工厂模式中，可以根据参数的不同返回不同的实例。简单工厂模式专门定义了一个类来创建其它类的实例，被创建的实例通常都有共同的父类。 结构 简单工厂包含了以下角色: Factory 工厂角色: 负责根据不同的参数创建不同的实例。 Product 抽象产品角色: 所有产品实例的父类，抽象描述产品实例的行为。 ProductA、ProductB 具象产品角色: 所有产品的实例，实现了抽象产品定义的逻辑。 场景示例简单工厂应用的场景比较对，那么就根据作者的理解，拿作者工作中遇到的场景需求举例： 平台做一个机票代购业务，对接了两个供应商A、B，用户选择完机票后，平台拿着机票去供应商下单。下单时根据机票由那个供应商提供去相应的供应商去下单。 常规实现 1234567891011121314151617public class Client2 &#123; private static final String TYPE_A = \"A\"; private static final String TYPE_B = \"B\"; public static void main(String[] args) &#123; String type = \"A\"; if (Objects.equals(TYPE_A, type)) &#123; // A 供应商下单逻辑处理 System.out.println(\"A供应商下单成功,下单时间\" + new Date()); &#125; else if (Objects.equals(TYPE_B, type)) &#123; // B 供应商下单逻辑处理 System.out.println(\"A供应商下单成功,下单时间\" + new Date()); &#125; else &#123; throw new RuntimeException(\"供应商不存在\"); &#125; &#125;&#125; 简单工厂实现 第一步就是定义一个下单接口。 123456public interface IVender &#123; /** * 供应商下单方法 */ void order();&#125; 然后分别实现A、B供应商的下单方法。 1234567891011121314public class VendorA implements IVender &#123; @Override public void order() &#123; // 业务逻辑处理 System.out.println(\"A供应商下单成功,下单时间\" + new Date()); &#125;&#125;public class VendorB implements IVender &#123; @Override public void order() &#123; // 业务逻辑处理 System.out.println(\"B供应商下单成功，下单时间：\" + new Date()); &#125;&#125; 接着定义一个工厂类，根据传入的不同参数请求，分别创建不同的供应商实例并返回，若碰到无效的参数，则抛出异常。 123456789101112public class VendorFactory &#123; public static IVender createVendor(String type) &#123; switch (type) &#123; case \"A\": return new VendorA(); case \"B\": return new VendorB(); default: throw new RuntimeException(\"供应商不存在\"); &#125; &#125;&#125; 最后，由我们客户端进行调用： 1234567public class Client &#123; public static void main(String[] args) &#123; String type = \"A\"; IVender iVender = VendorFactory.createVendor(type); iVender.order(); &#125;&#125; 优点 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。 缺点 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 使用场景在以下情况下可以使用简单工厂模式： 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。 JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。 1234public final static DateFormat getDateInstance();public final static DateFormat getDateInstance(int style);public final static DateFormat getDateInstance(int style,Localelocale); Java加密技术 1KeyGenerator keyGen=KeyGenerator.getInstance(\"DESede\"); 创建密码器 1Cipher cp=Cipher.getInstance(\"DESede\"); 总结 创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。 简单工厂模式又称为静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 简单工厂模式包含三个角色：工厂角色负责实现创建所有实例的内部逻辑；抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。 简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。 简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。","categories":[],"tags":[],"author":"Alex Tung"},{"title":"2020五一劳动节","slug":"2020五一劳动节","date":"2020-05-02T07:05:05.000Z","updated":"2020-05-02T07:05:05.110Z","comments":true,"path":"2020/05/02/2020五一劳动节/","link":"","permalink":"http://yoursite.com/2020/05/02/2020%E4%BA%94%E4%B8%80%E5%8A%B3%E5%8A%A8%E8%8A%82/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-05-02T02:23:24.117Z","updated":"2020-05-02T02:23:24.117Z","comments":true,"path":"2020/05/02/hello-world/","link":"","permalink":"http://yoursite.com/2020/05/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}