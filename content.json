{"meta":{"title":"Alex's blog","subtitle":"","description":"","author":"Alex Tung","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2020-05-02T03:33:26.000Z","updated":"2020-05-02T03:33:26.366Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2020-05-02T03:34:28.000Z","updated":"2020-05-02T03:34:28.601Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-05-02T03:34:13.000Z","updated":"2020-05-02T03:34:13.721Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"links","date":"2020-05-02T13:42:35.000Z","updated":"2020-05-02T13:42:35.679Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"repository","date":"2020-05-02T13:42:19.000Z","updated":"2020-05-02T13:42:19.359Z","comments":true,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"设计模式 | 工厂方法模式","slug":"设计模式-工厂方法模式","date":"2020-05-02T15:12:21.000Z","updated":"2020-05-02T15:31:54.641Z","comments":true,"path":"2020/05/02/设计模式-工厂方法模式/","link":"","permalink":"http://yoursite.com/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义动机现在对该系统进行修改，不再设计一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给专门的工厂子类去完成，我们先定义一个抽象的按钮工厂类，再定义具体的工厂类来生成圆形按钮、矩形按钮、菱形按钮等，它们实现在抽象按钮工厂类中定义的方法。这种抽象化的结果使这种结构可以在不修改具体工厂类的情况下引进新的产品，如果出现新的按钮类型，只需要为这种新类型的按钮创建一个具体的工厂类就可以获得该新按钮的实例，这一特点无疑使得工厂方法模式具有超越简单工厂模式的优越性，更加符合“开闭原则”。 定义工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 结构 工厂方法包含了一下角色 Product：抽象产品 ConcreteProduct：具象产品 Factory：抽象工厂 ConcreteFactory：具象工厂 示例Case 1还是拿售卖机票举例，我们之前用简单工厂实现了不同供应商的下单逻辑，但是随着业务的不断扩大，我们对接的供应商越来越多，这样就会造成每次对接一个供应商都会在工厂类中添加分支，对工厂类进行修改，这就违反了开闭原则，所以现在我们用工厂方法来修改一下。Factory代码 12345678910111213141516171819202122232425public interface Factory &#123; Product createProduct();&#125;public class AFactory implements Factory &#123; @Override public Product createProduct() &#123; return new AProduct(); &#125;&#125;public class BFactory implements Factory &#123; @Override public Product createProduct() &#123; return new BProduct(); &#125;&#125;public class CFactory implements Factory &#123; @Override public Product createProduct() &#123; return new CProdut(); &#125;&#125;... D... E Product代码 123456789101112131415161718192021222324public interface Product &#123; void createOrder();&#125;public class AProduct implements Product &#123; @Override public void createOrder() &#123; System.out.println(\"供应商A：下单操作\"); &#125;&#125;public class BProduct implements Product &#123; @Override public void createOrder() &#123; System.out.println(\"供应商B：下单操作\"); &#125;&#125;public class CProdut implements Product &#123; @Override public void createOrder() &#123; System.out.println(\"供应商B：下单操作\"); &#125;&#125;... D... E Client代码 12345678910public class Client &#123; public static void main(String[] args) &#123; Factory aFactory = new AFactory(); Product aProduct = aFactory.createProduct(); aProduct.createOrder(); Factory bFactory = new BFactory(); Product bProduct = bFactory.createProduct(); bProduct.createOrder(); &#125;&#125; 输出供应商A：下单操作 供应商B：下单操作以上就是一个简单的工厂方法的实现。即使在添加新的供应商，我们只要创建新的供应商工厂以及其实现就可以了，这样对我们的整个的工厂和产品体系都没有发生修改，而只是扩展了变化，这就完全符合了开放-闭合原则。如果我们的需求发生了变化，要同时支持单程、往返的下单，只要我们在每一个供应商作为一个简单工厂，创建出支持单程、往返的两种具象的产品就可以了。但是我们仔细观察就能发现，工厂方法模式实现时，客户端需要决定实例化哪一个工厂，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来运行，你想要什么功能，本来是去修改工厂的，但是现在是去修改了客户端！ Case 2日志记录器 某系统日志记录器要求支持多种日志记录方式，如文件记录、数据库记录等，且用户可以根据要求动态选择日志记录方式， 现使用工厂方法模式设计该系统。 结构图： 时序图： 优点 在工厂方法模式中，工厂方法用来创建客户端需要的产品，同时还向客户端隐藏了哪种具体产品类将被实例化这一细节，客户端只用关心产品对应的工厂，无需关心创建细节，甚至无需知道具体产品的类名。 面向接口编程，基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。 遵循开放-闭合原则，在系统中新增加一个产品时，不用更改抽象工厂以及抽象产品，也不用对客户端以及具象工厂和产品做修改，而只要添加一个具体工厂和具体产品就可以了。 缺点 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 使用场景 一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。 一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 扩展 使用多个工厂方法，可在抽象工厂中定义多个工厂方法，从而使具体工厂实现不同的工厂方法，这些工厂方法包含不同的逻辑，创建不同的产品（抽象工厂） 产品对象的重复使用： （1）工厂对象将已经创建过的产品保存到一个集合（如数组、List等）中，然后根据客户对产品的请求，对集合进行查询。如果有满足要求的产品对象，就直接将该产品返回客户端；如果集合中没有这样的产品对象，那么就创建一个新的满足要求的产品对象，然后将这个对象在增加到集合中，再返回给客户端。 （2）Spring单例模式的使用 多态性的丧失和模式的退化：如果工厂仅仅返回一个具体产品对象，便违背了工厂方法的用意，发生退化，此时就不再是工厂方法模式了。一般来说，工厂对象应当有一个抽象的父类型，如果工厂等级结构中只有一个具体工厂类的话，抽象工厂就可以省略，也将发生了退化。当只有一个具体工厂，在具体工厂中可以创建所有的产品对象，并且工厂方法设计为静态方法时，工厂方法模式就退化成简单工厂模式。(本例就可以简化为简单工厂模式) JDBC中的工厂方法: 1234Connection conn=DriverManager.getConnection(\"jdbc:microsoft:sqlserver://localhost:1433; DatabaseName=DB;user=sa;password=\");Statement statement=conn.createStatement();ResultSet rs=statement.executeQuery(\"select * from UserInfo\"); 总结 工厂方法模式又称为工厂模式，虚拟构造器模式。工厂方法中父类负责定义创建产品的统一接口，工厂子类负责生成具体的产品类。将产品的实例化操作延迟到子类进行，由子类决定实例化哪一个具体的产品类。 工厂方法模式包含四个角色：抽象工厂、具象工厂、抽象产品、具象产品 工厂方法模式是简单工厂的进一步的抽象和推广，它们都是集中封装了对象的创建，使得更换对象时不需要做大的改动就可以实现，降低了客户端程序与产品对象的耦合。但是由于工厂方法模式使用了多态性，工厂方法模式保持了简单工厂模式的有点，而且克服了它的缺点。 工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。 工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。","categories":[],"tags":[],"author":"Alex Tung"},{"title":"设计模式 | 简单工厂模式","slug":"设计模式-简单工厂模式","date":"2020-05-02T14:19:00.000Z","updated":"2020-05-02T15:09:42.200Z","comments":true,"path":"2020/05/02/设计模式-简单工厂模式/","link":"","permalink":"http://yoursite.com/2020/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"定义简单工厂模式（Simple Factory Pattern）：又称为静态工厂方法（Static Factory Method）模式，它属于类创建型模式，在简单工厂模式中，可以根据参数的不同返回不同的实例。简单工厂模式专门定义了一个类来创建其它类的实例，被创建的实例通常都有共同的父类。 结构 简单工厂包含了以下角色: Factory 工厂角色: 负责根据不同的参数创建不同的实例。 Product 抽象产品角色: 所有产品实例的父类，抽象描述产品实例的行为。 ProductA、ProductB 具象产品角色: 所有产品的实例，实现了抽象产品定义的逻辑。 场景示例简单工厂应用的场景比较对，那么就根据作者的理解，拿作者工作中遇到的场景需求举例： 平台做一个机票代购业务，对接了两个供应商A、B，用户选择完机票后，平台拿着机票去供应商下单。下单时根据机票由那个供应商提供去相应的供应商去下单。 常规实现 1234567891011121314151617public class Client2 &#123; private static final String TYPE_A = \"A\"; private static final String TYPE_B = \"B\"; public static void main(String[] args) &#123; String type = \"A\"; if (Objects.equals(TYPE_A, type)) &#123; // A 供应商下单逻辑处理 System.out.println(\"A供应商下单成功,下单时间\" + new Date()); &#125; else if (Objects.equals(TYPE_B, type)) &#123; // B 供应商下单逻辑处理 System.out.println(\"A供应商下单成功,下单时间\" + new Date()); &#125; else &#123; throw new RuntimeException(\"供应商不存在\"); &#125; &#125;&#125; 简单工厂实现 第一步就是定义一个下单接口。 123456public interface IVender &#123; /** * 供应商下单方法 */ void order();&#125; 然后分别实现A、B供应商的下单方法。 1234567891011121314public class VendorA implements IVender &#123; @Override public void order() &#123; // 业务逻辑处理 System.out.println(\"A供应商下单成功,下单时间\" + new Date()); &#125;&#125;public class VendorB implements IVender &#123; @Override public void order() &#123; // 业务逻辑处理 System.out.println(\"B供应商下单成功，下单时间：\" + new Date()); &#125;&#125; 接着定义一个工厂类，根据传入的不同参数请求，分别创建不同的供应商实例并返回，若碰到无效的参数，则抛出异常。 123456789101112public class VendorFactory &#123; public static IVender createVendor(String type) &#123; switch (type) &#123; case \"A\": return new VendorA(); case \"B\": return new VendorB(); default: throw new RuntimeException(\"供应商不存在\"); &#125; &#125;&#125; 最后，由我们客户端进行调用： 1234567public class Client &#123; public static void main(String[] args) &#123; String type = \"A\"; IVender iVender = VendorFactory.createVendor(type); iVender.order(); &#125;&#125; 优点 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。 缺点 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 使用场景在以下情况下可以使用简单工厂模式： 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。 JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。 1234public final static DateFormat getDateInstance();public final static DateFormat getDateInstance(int style);public final static DateFormat getDateInstance(int style,Localelocale); Java加密技术 1KeyGenerator keyGen=KeyGenerator.getInstance(\"DESede\"); 创建密码器 1Cipher cp=Cipher.getInstance(\"DESede\"); 总结 创建型模式对类的实例化过程进行了抽象，能够将对象的创建与对象的使用过程分离。 简单工厂模式又称为静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 简单工厂模式包含三个角色：工厂角色负责实现创建所有实例的内部逻辑；抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口；具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。 简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。 简单工厂模式适用情况包括：工厂类负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象不关心。","categories":[],"tags":[],"author":"Alex Tung"},{"title":"2020五一劳动节","slug":"2020五一劳动节","date":"2020-05-02T07:05:05.000Z","updated":"2020-05-02T07:05:05.110Z","comments":true,"path":"2020/05/02/2020五一劳动节/","link":"","permalink":"http://yoursite.com/2020/05/02/2020%E4%BA%94%E4%B8%80%E5%8A%B3%E5%8A%A8%E8%8A%82/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-05-02T02:23:24.117Z","updated":"2020-05-02T02:23:24.117Z","comments":true,"path":"2020/05/02/hello-world/","link":"","permalink":"http://yoursite.com/2020/05/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}